#  二元搜尋法（Binary Search）是一種高效的搜尋演算法，專門用來在 已排序的 列表或數組中查找目標值。它的工作原理是每次將搜尋範圍減半，
#  從而大幅度減少查找的次數。這種方法的時間複雜度是 𝑂(log 𝑛)，在大規模數據集上的表現非常優秀。


def binsrch(A, n, x, j):
    # 初始化下界為 1，這裡假設數組的索引從 1 開始（但要注意，Python 的索引是從 0 開始）
    lower = 1  # 警告：Python 的列表索引從 0 開始，通常 lower 應該初始化為 0
    # 初始化上界為 n（假設 n 是數組的長度）
    upper = n  # 警告：因為 Python 的索引從 0 開始，上界應該是 n-1

    # 當下界小於或等於上界時，繼續迴圈
    while lower <= upper:
        # 計算中間索引，使用整數除法以獲得整數結果
        mid = (lower + upper) // 2
        
        # 如果目標值 x 大於中間值 A[mid]，則目標值在右半部分
        if x > A[mid]:
            lower = mid + 1  # 將下界移動到 mid + 1
        
        # 如果目標值 x 小於中間值 A[mid]，則目標值在左半部分
        elif x < A[mid]:
            upper = mid - 1  # 將上界移動到 mid - 1
        
        # 如果找到目標值，則返回其索引
        else:
            j = mid  # 更新 j 為找到的索引 mid
            print("Found,", x, "is #", mid, "record.")  # 輸出找到的結果
            return j  # 返回找到的索引

    # 如果目標值不在數組中，通常會返回 -1 或其他標記值表示未找到
    return -1

# 注意事項：
# 1. 在 Python 中，列表的索引是從 0 開始的，而不是 1。
# 2. 因此，lower 應該初始化為 0，而 upper 應該初始化為 n-1。
# 3. 如果按照教科書的寫法，這段程式碼可能會忽略第一個元素並且可能超出列表的範圍。
# 4. 建議將 lower 改為 0，upper 改為 n-1，這樣才能正確覆蓋整個列表。

